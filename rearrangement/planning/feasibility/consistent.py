#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    Feasible Plan Problem class definition

    Defines the problem for the feasible plan search.

    Author: Abdul Rahman Dabbour
    Affiliation: CogRobo Lab, FENS, Sabanci University
    License: GNU Affero General Public License v3.0
    Repository: https://github.com/ardabbour/rearrangement/
"""

import copy
import time

from rearrangement.errors import type_error
from rearrangement.physics import Engine
from rearrangement.search import Problem, LocalSearch
from rearrangement.placement import Middle


class Consistent(Problem):
    """
    Consistent class definition

    This is a local search that attempts to reduce the number of collisions in a
    plan (a sequence of configurations) by fixing the collision in a single step
    and propagating the resulting changes across the rest of the plan.

    PARAMETERS
    ----------
    initial_state : Plan
        The initial state (plan) of the search problem.
    engine : Engine
        The pyBullet physics engine wrapper.
    start_time : float
        The starting time of the problem, in Unix time.
    
    ATTRIBUTES
    ----------
    initial_state : Plan
        The initial state (plan) of the search problem.
    engine : Engine
        The pyBullet physics engine wrapper.
    start_time : float
        The starting time of the problem, in Unix time.

    """

    def __init__(self, initial_state, engine, start_time=time.time()):

        self.start_time = start_time
        self.engine = engine

        super(Consistent, self).__init__(initial_state, maximality=False, lexi=True)

    @property
    def engine(self):
        return self.__engine

    @engine.setter
    def engine(self, engine):
        if isinstance(engine, Engine):
            self.__engine = engine
        else:
            raise type_error("engine", Engine, type(engine))

    @property
    def start_time(self):
        return self.__start_time

    @start_time.setter
    def start_time(self, start_time):
        if isinstance(start_time, float):
            self.__start_time = start_time
        else:
            raise type_error("start_time", float, type(start_time))

    def get_successors(self, state):
        """Given state S with configurations C0, C1, ..., Cn; n = |A|, it
        returns m successor states S'1, S'2, ..., S'm; m <= n

        Each successor state S'x has configurations
        C0, C1, ..., C'z, ..., C'y, ..., C'n
        where C'y is Cy with its collisions resolved by relocating objects J
        C'z is the earliest configuration where an instance of J exists
        Instances of objects J in C'z, C'z+1, ..., C'n relocated as in C'y

        Each successor state is generated by resolving the collisions of a
        single configuration in S."""

        def propagate(step_index, config, successor):
            """
            Propagates the changes in successor (with reference to configuration
            to all other configurations in successor.

            """

            # Reference configuration to which we will adjust the rest to
            ref_config = config
            ref_config = successor.configurations[step_index]

            max_index = len(successor.configurations)

            # For forward propagation, include the config index targeted
            forward_prop_indices = list(range(step_index + 1, max_index))

            # For backward propagation
            backward_prop_indices = list(reversed(range(1, step_index)))

            for ref_body_ind, ref_body in enumerate(ref_config.movable):

                for_stop_flag = False
                for for_ind in forward_prop_indices:
                    if for_stop_flag:
                        break
                    config = successor.configurations[for_ind]
                    body = config.movable[ref_body_ind]
                    same_cons = body.constraints == ref_body.constraints
                    if same_cons and not for_stop_flag:
                        body.pose = ref_body.pose
                    else:
                        for_stop_flag = True

                back_stop_flag = False
                for back_ind in backward_prop_indices:
                    config = successor.configurations[back_ind]
                    body = config.movable[ref_body_ind]
                    same_cons = body.constraints == ref_body.constraints
                    if same_cons and not back_stop_flag:
                        body.pose = ref_body.pose
                    else:
                        back_stop_flag = True

            return successor

        successors = set()
        for index, configuration in enumerate(state.configurations):
            in_collision = self.engine.get_collision_info(configuration)["status"]
            if in_collision:

                # Create a new plan
                successor = copy.deepcopy(state)

                # Select the configuration to resolve collisions in
                successor_configuration = successor.configurations[index]

                # Define collision resolving local search problem
                middle = Middle(copy.deepcopy(successor_configuration), self.engine)

                # Attempt to resolve collisions in selected configuration
                new_config = LocalSearch(
                    middle, timeout=1, start_time=self.start_time, random_restart=False
                ).simple()

                # Propagate the changes done by resolving the collisions to
                # the rest of the configurations in the plan.
                successor = propagate(index, new_config, successor)

                # Add the successor to the set of successors
                successors.add(successor)

        return successors

    def get_value(self, state):
        """
        Returns the value of the state. The value here is a cost that should be
        reduced and is made of two components: the number of bodies in collision
        and the total penetration depth of all collisions.

        PARAMETERS
        ----------
        state : Plan
            A plan.

        RETURNS
        -------
        cost : tuple
            The value (cost) of the state.    

        """

        cost = [0, 0, 0]
        for config in state.configurations:
            config_cost = self.engine.get_collision_info(config)
            if config_cost["status"]:
                cost[0] += 1
                cost[1] += config_cost["number"]
                cost[2] += config_cost["severity"]

        return tuple(cost)

    def get_random_restart(self):
        """
        Gets a random plan initialization.

        RETURNS
        -------
        randomized_state : Plan
            A random plan initialization.

        """
        randomized_state = copy.deepcopy(self.init_state)
        for config in randomized_state.configurations:
            config.randomize()

        return randomized_state
