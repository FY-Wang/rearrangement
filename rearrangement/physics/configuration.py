#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    Configuration class definition

    A configuration is the set of the physical surface, with its obstacles and
    the original objects already on it, as well as the new objects to be placed.

    Author: Abdul Rahman Dabbour
    Affiliation: CogRobo Lab, FENS, Sabanci University
    License: GNU Affero General Public License v3.0
    Repository: https://github.com/ardabbour/rearrangement/
"""

import json
import uuid

import numpy as np

from rearrangement.errors import type_error
from rearrangement.physics import Body


class Configuration(object):
    """
    Defines a configuration.

    Parameters
    ----------
    surface : Body
        the surface upon which bodies are to be placed/rearranged.
    obstacles : list
        the list of immovable bodies on the surface.
    originals : list
        the list of movable bodies on the surface.
    news : list
        the list of new movable bodies to be placed on the surface.

    Attributes
    ----------
    oid : UUID
        the UUID of the constraint; generated by uuid1.
    surface : Body
        the surface upon which bodies are to be placed/rearranged.
    obstacles : list
        the list of immovable bodies on the surface.
    originals : list
        the list of movable bodies on the surface.
    news : list
        the list of new movable bodies to be placed on the surface.
    movable : list
        the list of all movable bodies.
    collidable : list
        the list of all collidable bodies.
    all : list
        the list of all bodies.
    coverage : float
        the ratio of the area of all bodies to the surface area.
    """

    def __init__(self, surface, obstacles, originals, news):
        self.oid = uuid.uuid1()
        self.surface = surface
        self.obstacles = obstacles
        self.originals = originals
        self.news = news

        self.movable = self.originals + self.news
        self.collidable = self.obstacles + self.movable

        self.coverage = sum([x.area for x in self.collidable]) / self.surface.area

    @property
    def oid(self):
        return self.__oid

    @oid.setter
    def oid(self, oid):
        if isinstance(oid, uuid.UUID):
            self.__oid = oid
        else:
            raise type_error("oid", uuid.UUID, type(oid))

    @property
    def surface(self):
        return self.__surface

    @surface.setter
    def surface(self, surface):
        if isinstance(surface, Body):
            self.__surface = surface
        else:
            raise type_error("surface", Body, type(surface))

    @property
    def obstacles(self):
        return self.__obstacles

    @obstacles.setter
    def obstacles(self, obstacles):
        if isinstance(obstacles, list):
            for index, item in enumerate(obstacles):
                if not isinstance(item, Body):
                    raise type_error(
                        "index {} of obstacles".format(index), Body, type(item)
                    )
            self.__obstacles = obstacles
        else:
            raise type_error("obstacles", list, type(obstacles))

    @property
    def originals(self):
        return self.__originals

    @originals.setter
    def originals(self, originals):
        if isinstance(originals, list):
            for index, item in enumerate(originals):
                if not isinstance(item, Body):
                    raise type_error(
                        "index {} of originals".format(index), Body, type(item)
                    )
            self.__originals = originals
        else:
            raise type_error("obstacles", list, type(originals))

    @property
    def news(self):
        return self.__news

    @news.setter
    def news(self, news):
        if isinstance(news, list):
            for index, item in enumerate(news):
                if not isinstance(item, Body):
                    raise type_error("index {} of news".format(index), Body, type(item))
            self.__news = news
        else:
            raise type_error("obstacles", list, type(news))

    @property
    def movable(self):
        return self.__movable

    @movable.setter
    def movable(self, movable):
        if isinstance(movable, list):
            for index, item in enumerate(movable):
                if not isinstance(item, Body):
                    raise type_error(
                        "index {} of movable".format(index), Body, type(item)
                    )
            self.__movable = movable
        else:
            raise type_error("movable", list, type(movable))

    @property
    def collidable(self):
        return self.__collidable

    @collidable.setter
    def collidable(self, collidable):
        if isinstance(collidable, list):
            for index, item in enumerate(collidable):
                if not isinstance(item, Body):
                    raise type_error(
                        "index {} of collidable".format(index), Body, type(item)
                    )
            self.__collidable = collidable
        else:
            raise type_error("collidable", list, type(collidable))

    @property
    def coverage(self):
        return self.__coverage

    @coverage.setter
    def coverage(self, coverage):
        if isinstance(coverage, float):
            self.__coverage = coverage
        else:
            raise type_error("coverage", float, type(coverage))

    def reset_poses(self):
        """Resets the poses of all movable bodies."""

        for i in self.movable:
            for j in i:
                j.reset_pose()

    def update_configuration(self):
        for body in self.movable:
            body.update_pose()

    def find_body(self, oid):
        for body in self.collidable + [self.surface]:
            if body.oid == oid:
                return body
        return None

    def get_max_displacement(self, body):
        """Returns the maximum displacement the center point of a body can have
        from its initial pose based on the AABB of the surface."""

        s_aabb = self.surface.aabb_info
        anti_padding = s_aabb["2D diagonal length"] * 0.0125
        s_x_min = s_aabb["min x"] + anti_padding
        s_y_min = s_aabb["min y"] + anti_padding
        s_x_max = s_aabb["max x"] - anti_padding
        s_y_max = s_aabb["max x"] - anti_padding

        init_pose = body.init_pose
        max_x = max(abs(s_x_max - init_pose[0]), abs(s_x_min - init_pose[0]))
        max_y = max(abs(s_y_max - init_pose[1]), abs(s_y_min - init_pose[1]))

        return np.sqrt((max_x ** 2) + (max_y ** 2))

    @property
    def movement_info(self):
        """Returns a dictionary with information containing:
        1) A boolean depicting the existence of at least one moved original,
        2) the number of moved originals,
        3) the cumulative movement of all originals, and
        4) the moved originals.

        Note that movement is defined as
        (displacement of center) + (arc length displacement of AABB corner)."""

        def smallest_diff(angle_a, angle_b, unit="rad"):
            """Calculates the smallest difference between two angles."""

            diff = angle_a - angle_b
            if unit == "deg":
                return abs((diff + np.pi) % 2 * np.pi - np.pi)
            return abs((diff + np.pi) % np.pi)

        moved = False
        movement = 0
        moved_bodies = set()
        no_of_moved_bodies = 0
        for body in self.originals:
            pose = body.pose
            init_pose = body.init_pose

            x_disp = pose[0] - init_pose[0]
            y_disp = pose[1] - init_pose[1]
            disp = np.sqrt((x_disp ** 2) + (y_disp ** 2))

            char_len = body.aabb_info["2D diagonal length"] / 2
            rot = smallest_diff(pose[2], init_pose[2]) * char_len

            if disp > 0:
                moved = True
                moved_bodies.add(body)
                movement += disp + rot
                no_of_moved_bodies += 1

        move_info = {
            "status": moved,
            "number": no_of_moved_bodies,
            "severity": movement,
            "list": list(moved_bodies),
        }

        return move_info

    def dump_json(self):
        """Returns the configuration as a JSON object."""

        def unpack(obj, surf):
            """Unpacks an object into a dictionary."""

            dic = {}
            for item in obj:
                key = item.name
                path = item.path
                if "real" in path:
                    z_pos = item.z_off / 15.0
                else:
                    z_pos = item.z_off
                z_off = z_pos - surf.z_off
                value = {
                    "path": path,
                    "pose": item.pose,
                    "z offset": z_off,
                    "area": item.area,
                }
                dic[key] = value
            return dic

        surface = {
            "path": self.surface.path,
            "pose": self.surface.pose,
            "z offset": self.surface.z_off,
            "area": self.surface.area,
        }
        originals = unpack(self.originals, self.surface)
        news = unpack(self.news, self.surface)
        obstacles = unpack(self.obstacles, self.surface)
        data = {
            "surface": surface,
            "obstacles": obstacles,
            "originals": originals,
            "news": news,
        }

        return json.dumps(data, sort_keys=True, indent=4)

    def randomize(self):
        """Randomizes the configuration with a uniform distribution"""

        s_aabb = self.surface.aabb_info
        anti_padding = s_aabb["2D diagonal length"] * 0.0125
        s_x_min = s_aabb["min x"] + anti_padding
        s_y_min = s_aabb["min y"] + anti_padding
        s_x_max = s_aabb["max x"] - anti_padding
        s_y_max = s_aabb["max x"] - anti_padding

        for body in self.movable:
            rand_x = np.random.uniform(s_x_min, s_x_max)
            rand_y = np.random.uniform(s_y_min, s_y_max)
            rand_theta = np.random.uniform(0, 2 * np.pi)
            body.pose = [rand_x, rand_y, rand_theta]
