#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    Body class definition

    A body is the simplest unit: it is a physical object that must be placed on
    top of a physical surface by the end of the operation. Constraints on each
    body are defined here.

    Author: Abdul Rahman Dabbour
    Affiliation: CogRobo Lab, FENS, Sabanci University
    License: GNU Affero General Public License v3.0
    Repository: https://github.com/ardabbour/rearrangement/
"""

import uuid

import numpy as np
import pybullet as p

from rearrangement.physics import to_euler, to_quaternion, Constraint
from rearrangement.errors import type_error, value_error, length_error


class Body(object):
    """
    A wrapper for a physical body loaded into Bullet.

    Parameters
    ----------
    bid : int
        the body ID assigned by the physics engine.
    color : list
        a list of floats 0.0-1.0 describing the body color in RGBA format.
    name : str
        the name of the body.
    pose : list
        a list of floats describing the pose of the body in [x, y, yaw].
    constraints : list
        a list of Constraints.
    z_off : float
        the distance from the centroid of the body to its lower extreme.
    area: float
        the greatest cross-sectional area of the body parallel to the x-y plane.
    path: str
        the path to the URDF file describing the body.

    Attributes
    ----------
    oid : UUID
        the uuid of the body; generated by uuid1.
    bid : int
        the physics engine ID of the body.
    name : str
        the name of the body.
    area : float
        the greatest cross-section area of the body parallel to the x-y plane.
    path : str
        the path to the URDF file describing the body.
    init_color : list
        the initial RGBA color of the body
    color : list
        the RGBA color of the body
    init_pose : list
        the initial [x, y, yaw] pose of the body.
    pose : list
        the [x, y, yaw] pose of the body.
    constraints : Constraint
        The list of constraints acting on the body.
    z_off : float
        the distance from the centroid of the body to its lower extreme.

    """

    def __init__(self, bid, color, name, pose, constraints, z_off, area, path):
        self.oid = uuid.uuid1()
        self.bid = bid
        self.name = name
        self.area = area
        self.path = path
        self.init_color = color
        self.color = color
        self.init_pose = pose
        self.constraints = constraints
        self.z_off = z_off
        self.pose = pose

    def reset_color(self):
        """Resets the color of the body to its initial value."""

        self.color = self.init_color

    def reset_pose(self):
        """Resets the pose of the body to its initial value."""

        self.pose = self.init_pose

    @property
    def aabb_info(self):
        """Returns information on the aligned axis bounding box of the body."""

        aabb = p.getAABB(self.bid)
        x_min = aabb[0][0]
        x_max = aabb[1][0]
        y_min = aabb[0][1]
        y_max = aabb[1][1]
        z_min = aabb[0][2]
        z_max = aabb[1][2]

        long_edge_length = abs(max(x_max - x_min, y_max - y_min))
        short_edge_length = abs(min(x_max - x_min, y_max - y_min))
        diagonal_length = np.sqrt(((x_max - x_min) ** 2) + ((y_max - y_min) ** 2))

        return {
            "min x": x_min,
            "max x": x_max,
            "min y": y_min,
            "max y": y_max,
            "min z": z_min,
            "max z": z_max,
            "2D long edge length": long_edge_length,
            "2D short edge length": short_edge_length,
            "2D diagonal length": diagonal_length,
        }

    def find_constraint(self, oid):
        """Returns the constraint specified by its OID."""

        for constraint in self.constraints:
            if constraint.oid == oid:
                return constraint
        return None

    def update_pose(self):
        """Syncronizes the physics engine's pose of the body with the one
        defined in self.__pose. To be used after the stepSimulation method."""

        pos, orn = p.getBasePositionAndOrientation(self.bid)
        self.pose = [pos[0], pos[1], to_euler(orn)[2]]

    def _get_constrained_pose(self, pose):
        """Constrains the pose to comply with the constraints in the body."""

        def _get_closest_valid_point(pose, constraint):
            """Returns the closest point to the constraint if the pose is out of
            bounds; otherwise returns the pose given to it."""

            shape = constraint.shape
            geometry = constraint.geometry

            if shape == "rectangular":
                if pose[0] > geometry["max x"]:
                    x_pose = geometry["max x"]
                elif pose[0] < geometry["min x"]:
                    x_pose = geometry["min x"]
                else:
                    x_pose = pose[0]

                if pose[1] > geometry["max y"]:
                    y_pose = geometry["max y"]
                elif pose[1] < geometry["min y"]:
                    y_pose = geometry["min y"]
                else:
                    y_pose = pose[1]

                return [x_pose, y_pose, pose[2]]

            elif shape == "circular":
                if geometry["radius"] == 0:
                    return [geometry["center"][0], geometry["center"][1], pose[2]]
                x_dist = geometry["center"][0] - pose[0]
                y_dist = geometry["center"][1] - pose[1]
                dist = np.sqrt((y_dist ** 2) + (x_dist ** 2))

                if not (round(dist, 2) <= round(geometry["radius"], 2)):
                    x_pose = geometry["center"][0] + (
                        (x_dist / dist) * geometry["radius"]
                    )
                    y_pose = geometry["center"][1] + (
                        (y_dist / dist) * geometry["radius"]
                    )
                    return [x_pose, y_pose, pose[2]]

            elif shape == "rotational":
                if pose[2] > geometry["max"]:
                    return [pose[0], pose[1], geometry["max"]]
                elif pose[2] < geometry["min"]:
                    return [pose[0], pose[1], geometry["min"]]

            return pose

        for constraint in self.constraints:
            pose = _get_closest_valid_point(pose, constraint)

        return pose

    @property
    def oid(self):
        return self.__oid

    @oid.setter
    def oid(self, oid):
        if isinstance(oid, uuid.UUID):
            self.__oid = oid
        else:
            raise type_error("oid", uuid.UUID, type(oid))

    @property
    def bid(self):
        return self.__bid

    @bid.setter
    def bid(self, bid):
        if isinstance(bid, int):
            self.__bid = bid
        else:
            raise type_error("bid", int, type(bid))

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        if isinstance(name, str):
            self.__name = name
        else:
            raise type_error("name", str, type(name))

    @property
    def area(self):
        return self.__area

    @area.setter
    def area(self, area):
        if isinstance(area, float):
            if area < 0.0:
                raise value_error("area", "x >= 0", area)
            self.__area = area
        else:
            raise type_error("area", float, type(area))

    @property
    def path(self):
        return self.__path

    @path.setter
    def path(self, path):
        if isinstance(path, str):
            self.__path = path
        else:
            raise type_error("path", str, type(path))

    @property
    def init_color(self):
        return self.__init_color

    @init_color.setter
    def init_color(self, color):
        if isinstance(color, list):
            for index, item in enumerate(color):
                if not isinstance(item, float):
                    raise type_error(
                        "index {} of init color".format(index), float, type(item)
                    )
                if item > 1.0 or item < 0.0:
                    raise value_error("index {} of init color", "0 >= x >= 1", item)
            self.__init_color = color
        else:
            raise type_error("init color", list, type(color))

    @property
    def color(self):
        return self.__color

    @color.setter
    def color(self, color):
        if isinstance(color, list):
            for index, item in enumerate(color):
                if not isinstance(item, float):
                    raise type_error(
                        "index {} of color".format(index), float, type(item)
                    )
                if item > 1.0 or item < 0.0:
                    raise value_error("index {} of color", "0 >= x >= 1", item)

            # TODO: handle multiple links better
            p.changeVisualShape(self.__bid, -1, rgbaColor=color)
            p.changeVisualShape(self.__bid, 0, rgbaColor=color)
            p.changeVisualShape(self.__bid, 1, rgbaColor=color)
            p.changeVisualShape(self.__bid, 2, rgbaColor=color)

            self.__color = color
        else:
            raise type_error("color", list, type(color))

    @property
    def init_pose(self):
        return self.__init_pose

    @init_pose.setter
    def init_pose(self, pose):
        self.__init_pose = pose

    @property
    def pose(self):
        return self.__pose

    @pose.setter
    def pose(self, pose):
        if isinstance(pose, list):
            for index, item in enumerate(pose):
                if not isinstance(item, float):
                    raise type_error(
                        "index {} of pose".format(index), float, type(item)
                    )
            if not len(pose) == 3:
                raise length_error("pose", 3, len(pose))
            pose = self._get_constrained_pose(pose)
            self.__pose = pose
            pos = [pose[0], pose[1], self.z_off]
            orn = to_quaternion([0, 0, pose[2]])
            p.resetBasePositionAndOrientation(self.__bid, pos, orn)
        else:
            raise type_error("pose", list, type(pose))

    @property
    def constraints(self):
        """Property that holds the list of constraints of the body."""

        return self.__constraints

    @constraints.setter
    def constraints(self, constraints):
        """Setter for the constraints property."""

        if not isinstance(constraints, list):
            raise type_error("constraints", list, type(constraints))

        for index, item in enumerate(constraints):
            if not isinstance(item, Constraint):
                raise type_error(
                    "index {} of constraints".format(index), Constraint, type(item)
                )

        self.__constraints = constraints

    def add_constraint(self, constraint):

        self.__constraints.append(constraint)

    def remove_constraint(self, constraint):
        """Removes an existing constraint to the body's pose."""

        self.__constraints.remove(constraint)

    @property
    def z_off(self):
        """Property that holds the z-offset of the body."""

        return self.__z_off

    @z_off.setter
    def z_off(self, z_off):
        """Setter for the z_off property."""

        if not isinstance(z_off, float):
            raise type_error("z_off", float, type(z_off))

        self.__z_off = z_off
